# Copyright (c) 2019 Wladislaw Wagner (Vitasystems GmbH), Pablo Pazos (Hannover Medical School).
#
# This file is part of Project EHRbase
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.



*** Settings ***
Documentation   AQL Integration Tests
...            Precondtions:
...              1. operational_templates folder is empty
...              2. CLEAN DB container started !!!
...              3. openehr-server (jar) started

Library    Collections
Library    OperatingSystem
Resource    ${CURDIR}${/}../_resources/suite_settings.robot
# Resource    ${CURDIR}${/}../_resources/keywords/ethercis_keywords.robot
Resource    ${CURDIR}${/}../_resources/keywords/ehr_keywords.robot
Resource    ${CURDIR}${/}../_resources/keywords/template_opt1.4_keywords.robot

Suite Setup  startup SUT
Suite Teardown  shutdown SUT

Force Tags      AQL    obsolete

*** Variables ***
${response_json}    {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad"}
${expected_json}    {"key1": 77, "key2": "string", "key3": [1,2,3,"sring"], "name": "OTTO", "age": 33}

${VALID DATA SETS}    ${PROJECT_ROOT}${/}tests${/}robot${/}_resources${/}test_data_sets${/}valid_templates
${INVALID DATA SETS}    ${PROJECT_ROOT}${/}tests${/}robot${/}_resources${/}test_data_sets${/}invalid_templates
${DATA SETS}    ${PROJECT_ROOT}${/}tests${/}robot${/}_resources${/}test_data_sets
${JSON FIXTURES}    ${PROJECT_ROOT}${/}tests${/}robot${/}_resources${/}fixtures${/}expected_responses



*** Test Cases ***
Upload needed templates

    upload valid template (XML)    /minimal/minimal_action.opt
    upload valid template (XML)    /minimal/minimal_observation.opt
    upload valid template (XML)    /minimal/minimal_evaluation.opt
    upload valid template (XML)    /minimal/minimal_admin.opt
    upload valid template (XML)    /minimal/minimal_instruction.opt
    upload valid template (XML)    /all_types/Test_all_types.opt



# EXAMPLES OF USAGE
json payloads should match exactly
    ${response_json}  Set Variable  {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad"}
    ${expected_json}  Set Variable  perfectmatch.json
    # the next is a keyword with embedded arguments
    ${response_json} should exactly match ${expected_json}

json payloads should match exactly (fail)
    ${response_json}  Set Variable  {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad"}
    ${expected_json}  Set Variable  aqlresponse_01.json
    Run Keyword And Expect Error    JsonCompareError:*
    ...                             ${response_json} should exactly match ${expected_json}

response payload is subset of expected json 1
    ${response_json}  Set Variable  {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad", "age": 99}
    ${expected_json}  Set Variable  perfectmatch.json
    is subset of  ${response_json}  ${expected_json}

response payload is subset of expected json 2
    ${response_json}  Set Variable  {"key0": false, "key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad", "age": 99}
    ${expected_json}  Set Variable  perfectmatch.json
    is subset of  ${response_json}  ${expected_json}

response payload is subset of expected json 3
    ${response_json}  Set Variable  {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "age": 99}
    ${expected_json}  Set Variable  perfectmatch.json
    # here we exclude "name": "wlad" from beeing required
    # this is a way to exclude keys with dynamic values like timestamps or
    # autogenerated id etc.
    is subset of  ${response_json}  ${expected_json}  exclude_paths=root['name']

response payload is subset of expected json file (fail)
    ${response_json}  Set Variable  {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad"}
    ${expected_json}  Set Variable  aqlresponse_01.json
    # the next is a keyword with embedded arguments
    Run Keyword And Expect Error    JsonCompareError: Payload is not subset of expected!
    ...                             is subset of  ${response_json}  ${expected_json}

compare json payloads 1
    [Documentation]  this test does not fail because no validation takes place,
    ...              just a comparison, you can check the results in log.html
    # variables are taken from *** Variables *** section
    &{json1}=    Evaluate    json.loads('''${response_json}''')    json
    &{json2}=    Evaluate    json.loads('''${expected_json}''')    json
    compare_json_payloads  ${json1}  ${json2}

compare json payloads 2
    &{json1}=    Evaluate    json.loads('{"1": 1, "2": 2, "3": 3}')    json
    &{json2}=    Evaluate    json.loads('{"1": 1, "2": 7, "3": 3}')    json
    compare_json_payloads  ${json1}  ${json2}

compare json payloads 3
    &{json1}=    Evaluate    json.loads('''{"1": 1, "2": 2, "3": 3}''')    json
    &{json2}=    Evaluate    json.loads('''{"1": "otto", "2": 7, "3": 3}''')    json
    compare_json_payloads  ${json1}  ${json2}

json payloads should match 1
    ${response_json}  Set Variable  {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad"}
    ${expected_json}  Set Variable  {"key1": 33, "key2": "string", "key3": [1,2,3,"string"], "name": "wlad"}
    ${json1}=    Evaluate    json.loads('''${response_json}''')    json
    ${json2}=    Evaluate    json.loads('''${expected_json}''')    json
    subset_of_expected  ${json1}  ${json2}


# TEST USING THE LESS ADVANCED BUT EASY TO USE JSONDIFF LIB
response meets expectation 1
    &{json1}=    Evaluate    json.loads('''${response_json}''')    json
    &{json2}=    Evaluate    json.loads('''${expected_json}''')    json
    Log Dictionary    ${json1}
    Log Dictionary    ${json2}
    # ${type}=    evaluate    type(&{json2})
    Run Keyword And Expect Error  JsonCompareError: Diff found:*
    ...                           response_meets_expectation  ${json1}  ${json2}

response meets expectation 2
    &{json1}=    Evaluate    json.loads('''${response_json}''')    json
    ${jsonfile}    Get File    ${JSON FIXTURES}/perfectmatch.json
    &{json2}=    Evaluate    json.loads('''${jsonfile}''')    json
    Log Dictionary    ${json1}
    Log Dictionary    ${json2}
    # ${type}=    evaluate    type(${json1}).__name__
    # ${type}=    evaluate    type(&{json2})
    response_meets_expectation  ${json1}  ${json2}



# EXAMPLES WITH REAL AQL QEURY RESPONSES
AQL query JSON payload test 1
    [Documentation]  This test will fail because of dynamic ehr_id
    ...              the JSONDIFF lib can not handle this
    ...              Solution 1) is to set the ehr_id into expected json
    ...              before validation
    ...              Solution 2) is to use keywords that are based on DeepDiff and
    ...              exclude keys with dynamic values with `exclude_paths` arg
    ...              check next test as example for Solution 2
    [Tags]   not-ready
    create ehr   1234-666   namespace_666
    extract ehrId

    &{resp}=  REST.POST   /query  {"aql" : "select a/uid/value as uid, a/composer/name as author, a/context/start_time/value as date_created from EHR e [ehr_id/value = '${ehr_id}'] contains COMPOSITION a[openEHR-EHR-COMPOSITION.health_summary.v1]"}
    Set Test Variable    ${response}    ${resp}
    expect response status  200

    ${response_json}    Output   response body
    ${jsonfile}    Get File    ${JSON FIXTURES}/aqlresponse_01.json
    &{expected_json}    Evaluate   json.loads("""${jsonfile}""")    json
    compare_json_payloads  ${response_json}  ${expected_json}
    Run Keyword And Expect Error  JsonCompareError: Diff found:*
    ...                           response_meets_expectation  ${response_json}  ${expected_json}

AQL query JSON payload test with exclude_paths argument
    [Documentation]  This test demonstrates use of keyword with `exclude_paths` arg
    ...              avoiding FAIL as result of dynamic values in response
    [Tags]    not-ready
    create ehr   1234-667   namespace_667
    extract ehrId

    &{resp}=  REST.POST   /query    {"aql" : "select a/uid/value as uid, a/composer/name as author, a/context/start_time/value as date_created from EHR e [ehr_id/value = '${ehr_id}'] contains COMPOSITION a[openEHR-EHR-COMPOSITION.health_summary.v1]"}
    Set Test Variable    ${response}    ${resp}
    expect response status  200

    ${response_json}  Output  response body
    ${type}=    evaluate    type(${response_json})
    Log Dictionary    ${response_json}

    ${expected_json}  Set Variable  aqlresponse_01.json
    response is subset of  ${response_json}  ${expected_json}  exclude_paths=root['executedAQL']

AQL for committed data ADMIN_ENTRY (fail)
    [Documentation]  Another example of failing test due to dynamic values of
    ...              some keys in JSON response
    [Tags]  not-ready
    ${subject_id}=    Generate Random String    16    [NUMBERS]abcdef
    create ehr    ${subject_id}    local.ehr
    extract ehrId    # sets the ehr_id variable

    #create composition
    REST.POST    /composition?ehrId=${ehr_id}&templateId=minimal_admin.en.v1&format=FLAT
    ...          ${DATA SETS}/flat_compositions/minimal_admin.en.v1.instance_flat_input_1.json
    Integer    response status    200  201
    ${response_json}  Output  response body
    ${jsonfile}    Get File    ${JSON FIXTURES}/composition_01.json
    ${expected_json}  Evaluate    json.loads('''${jsonfile}''')    json
    Run Keyword And Expect Error    JsonCompareError: Diff found:*
    ...           response_meets_expectation  ${response_json}  ${expected_json}

    REST.POST    /query    {"aql": "SELECT c/uid/value, c/archetype_node_id, c/archetype_details/template_id/value, a/time/value as action_time, a/ism_transition/current_state/value as current_state, a/description[at0001]/items[at0002]/value/uri/value as mm_uri, a/description[at0001]/items[at0002]/value/size as mm_size FROM EHR e [ehr_id/value='${ehr_id}'] CONTAINS COMPOSITION c [openEHR-EHR-COMPOSITION.minimal.v1] CONTAINS ADMIN_ENTRY a [openEHR-EHR-ADMIN_ENTRY.minimal.v1]"}
    Integer    response status    200
    Array    $.resultSet    minItems=1    maxItems=1
    ${response_json}  Output   response body
    ${jsonfile}    Get File    ${JSON FIXTURES}/aqlresponse_02.json
    ${expected_json}  Evaluate    json.loads('''${jsonfile}''')    json
    Run Keyword And Expect Error    JsonCompareError: Diff found:*
    ...           response_meets_expectation  ${response_json}  ${expected_json}

AQL for committed data ADMIN_ENTRY
    [Documentation]  Same test as above but exluding problematic paths in JSON
    ...              response to avoid failing
    [Tags]  not-ready
    ${subject_id}=    Generate Random String    16    [NUMBERS]abcdef
    create ehr    ${subject_id}    local.ehr
    extract ehrId    # sets the ehr_id variable

    #create composition
    REST.POST    /composition?ehrId=${ehr_id}&templateId=minimal_admin.en.v1&format=FLAT
    ...          ${DATA SETS}/flat_compositions/minimal_admin.en.v1.instance_flat_input_1.json
    Integer    response status    200  201
    ${response_json}  Output  response body
    ${expected_json}  Set Variable  composition_01.json
    ${exclude_paths}  Create List  root['meta']['href']['url']  root['compositionUid']
    Log  ${exclude_paths}
    ${type}=    evaluate    type(${exclude_paths})
    response is subset of  ${response_json}  ${expected_json}  exclude_paths=${exclude_paths}

    REST.POST    /query    {"aql": "SELECT c/uid/value, c/archetype_node_id, c/archetype_details/template_id/value, a/time/value as action_time, a/ism_transition/current_state/value as current_state, a/description[at0001]/items[at0002]/value/uri/value as mm_uri, a/description[at0001]/items[at0002]/value/size as mm_size FROM EHR e [ehr_id/value='${ehr_id}'] CONTAINS COMPOSITION c [openEHR-EHR-COMPOSITION.minimal.v1] CONTAINS ADMIN_ENTRY a [openEHR-EHR-ADMIN_ENTRY.minimal.v1]"}
    Integer    response status    200
    Array    $.resultSet    minItems=1    maxItems=1
    ${response_json}  Output   response body
    ${expected_json}  Set Variable  aqlresponse_02.json
    ${exclude_paths}  Create List  root['resultSet'][0]  root['executedAQL']
    response is subset of  ${response_json}  ${expected_json}  exclude_paths=${exclude_paths}

Find UID's JSON Path
    [Documentation]  TODO: what is path of uid?
    ...              root['resultSet'][0] excludes the whole dict that is at
    ...              index 0 in resultSet. This is not what we want!
    ...              We want to exclude uid only - possibly regardless the index
    ${file1}  Get File  ${JSON FIXTURES}/aqlresponse_02.json
    ${actual_json}  Evaluate  json.loads('''${file1}''')    json
    ${expected_json}  Set Variable  aqlresponse_03.json
    ${exclude_paths}  Create List
    ...               root['resultSet'][0]
    ...               root['executedAQL']
    ...               root['action']
    response is subset of  ${actual_json}  ${expected_json}  exclude_paths=${exclude_paths}



*** Keywords ***
startup SUT
    [Documentation]  used in Test Suite Setup
    ...              this keyword overrides another one with same name
    ...              from "generic_keywords.robot" file
    get application version
    empty operational_templates folder
    start ehrdb
    start openehr server

${response payload} should exactly match ${expected json-file}
    [Documentation]  Keyword requires a PATH to expected .json file
    ...              relative to ${JSON FIXTURES}/
    ${jsonfile}    Get File    ${JSON FIXTURES}/${expected json-file}
    ${json1}=    Evaluate    json.loads('''${response payload}''')    json
    ${json2}=    Evaluate    json.loads('''${jsonfile}''')    json
    Log Dictionary    ${json1}
    Log Dictionary    ${json2}
    # payloads are passed to custom lib jsohnlib.py
    payloads should match exactly  ${json1}  ${json2}

is subset of
    [Documentation]  Checks if "given json" is subset of "expected json".
    ...              Use this to compare two files. Don't use it with API requests.
    ...              Keyword requires a PATH to expected .json file
    ...              relative to ${JSON FIXTURES}/
    ...
    [Arguments]  ${actual}  ${expected}  ${exclude_paths}=None

    ${json1}=  Evaluate  json.loads('''${actual}''')    json
    ${jsonfile}  Get File  ${JSON FIXTURES}/${expected}
    ${json2}=    Evaluate    json.loads('''${jsonfile}''')    json
    # Log Dictionary    ${json1}
    # Log Dictionary    ${json2}
    # payloads are passed to custom lib jsohnlib.py
    subset of expected  ${json1}  ${json2}  ${exclude_paths}

response is subset of
    [Documentation]  Checks if HTTP API "response payload" is subset of expected
    ...              result which was saved to a json file previously.
    ...              Use this with real API requests.
    ...              Keyword requires a PATH to expected .json file
    ...              relative to ${JSON FIXTURES}/
    [Arguments]  ${response payload}  ${expected json-file}  ${exclude_paths}=None
    ${json1}=    Set Variable  ${response payload}
    ${type}=    evaluate    type(${json1})

    ${jsonfile}    Get File    ${JSON FIXTURES}/${expected json-file}
    ${json2}=    Evaluate    json.loads('''${jsonfile}''')    json
    ${type}=    evaluate    type(${json2})

    # payloads are passed to custom lib jsohnlib.py
    subset of expected  ${json1}  ${json2}  ${exclude_paths}





# BACKUP
# JSON from file
#     ${port_uuid}=    Set Variable    ${321}
#     ${filejson}=    OperatingSystem.GetFile    ${JSON FIXTURES}/aqlresponse_01.json
#     &{json}=    Evaluate    json.loads('''${filejson}''')    json
#     Log Dictionary    ${json}
#     Set To Dictionary    ${json}    id    ${port_uuid}
#     ${filejson}=    Evaluate    json.dumps(${json})    json
#     Log    ${filejson}
#     OperatingSystem.Append To File    newpayload.json    ${filejson}
#     Log File    newpayload.json
#
# ${expected result}  Convert To Dictionary    ${json file}
# Dictionary Should Contain Sub Dictionary    dict1    dict2
# Dictionaries Should Be Equal    ${result}    ${expected result}
